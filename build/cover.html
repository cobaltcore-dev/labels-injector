
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cobaltcore-dev/labels-injector/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/cobaltcore-dev/labels-injector/internal/controller/pod_controller.go (0.0%)</option>
				
				<option value="file2">github.com/cobaltcore-dev/labels-injector/internal/transfer_label.go (0.0%)</option>
				
				<option value="file3">github.com/cobaltcore-dev/labels-injector/internal/webhook/v1/webhook.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
SPDX-FileCopyrightText: 2025 SAP SE or an SAP affiliate company
SPDX-License-Identifier: Apache-2.0

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "crypto/tls"
        "flag"
        "os"
        "path/filepath"

        // Import all Kubernetes client auth plugins (e.g. Azure, GCP, OIDC, etc.)
        // to ensure that exec-entrypoint and run can make use of them.
        _ "k8s.io/client-go/plugin/pkg/client/auth"

        "github.com/sapcc/go-api-declarations/bininfo"
        "k8s.io/apimachinery/pkg/runtime"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
        clientgoscheme "k8s.io/client-go/kubernetes/scheme"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/certwatcher"
        "sigs.k8s.io/controller-runtime/pkg/healthz"
        "sigs.k8s.io/controller-runtime/pkg/log/zap"
        "sigs.k8s.io/controller-runtime/pkg/metrics/filters"
        metricsserver "sigs.k8s.io/controller-runtime/pkg/metrics/server"
        "sigs.k8s.io/controller-runtime/pkg/webhook"

        "github.com/cobaltcore-dev/labels-injector/internal/controller"
        webhookkvmcloudsapv1 "github.com/cobaltcore-dev/labels-injector/internal/webhook/v1"
        // +kubebuilder:scaffold:imports
)

var (
        scheme   = runtime.NewScheme()
        setupLog = ctrl.Log.WithName("setup")
)

func init() <span class="cov0" title="0">{
        utilruntime.Must(clientgoscheme.AddToScheme(scheme))
        // +kubebuilder:scaffold:scheme
}</span>

//nolint:gocyclo
func main() <span class="cov0" title="0">{
        var metricsAddr string
        var metricsCertPath, metricsCertName, metricsCertKey string
        var webhookCertPath, webhookCertName, webhookCertKey string
        var enableLeaderElection bool
        var probeAddr string
        var secureMetrics bool
        var enableHTTP2 bool
        var tlsOpts []func(*tls.Config)
        flag.StringVar(&amp;metricsAddr, "metrics-bind-address", "0", "The address the metrics endpoint binds to. "+
                "Use :8443 for HTTPS or :8080 for HTTP, or leave as 0 to disable the metrics service.")
        flag.StringVar(&amp;probeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")
        flag.BoolVar(&amp;enableLeaderElection, "leader-elect", false,
                "Enable leader election for controller manager. "+
                        "Enabling this will ensure there is only one active controller manager.")
        flag.BoolVar(&amp;secureMetrics, "metrics-secure", true,
                "If set, the metrics endpoint is served securely via HTTPS. Use --metrics-secure=false to use HTTP instead.")
        flag.StringVar(&amp;webhookCertPath, "webhook-cert-path", "", "The directory that contains the webhook certificate.")
        flag.StringVar(&amp;webhookCertName, "webhook-cert-name", "tls.crt", "The name of the webhook certificate file.")
        flag.StringVar(&amp;webhookCertKey, "webhook-cert-key", "tls.key", "The name of the webhook key file.")
        flag.StringVar(&amp;metricsCertPath, "metrics-cert-path", "",
                "The directory that contains the metrics server certificate.")
        flag.StringVar(&amp;metricsCertName, "metrics-cert-name", "tls.crt", "The name of the metrics server certificate file.")
        flag.StringVar(&amp;metricsCertKey, "metrics-cert-key", "tls.key", "The name of the metrics server key file.")
        flag.BoolVar(&amp;enableHTTP2, "enable-http2", false,
                "If set, HTTP/2 will be enabled for the metrics and webhook servers")
        opts := zap.Options{
                Development: true,
        }
        opts.BindFlags(flag.CommandLine)
        bininfo.HandleVersionArgument()
        flag.Parse()

        ctrl.SetLogger(zap.New(zap.UseFlagOptions(&amp;opts)))

        // if the enable-http2 flag is false (the default), http/2 should be disabled
        // due to its vulnerabilities. More specifically, disabling http/2 will
        // prevent from being vulnerable to the HTTP/2 Stream Cancellation and
        // Rapid Reset CVEs. For more information see:
        // - https://github.com/advisories/GHSA-qppj-fm5r-hxr3
        // - https://github.com/advisories/GHSA-4374-p667-p6c8
        disableHTTP2 := func(c *tls.Config) </span><span class="cov0" title="0">{
                setupLog.Info("disabling http/2")
                c.NextProtos = []string{"http/1.1"}
        }</span>

        <span class="cov0" title="0">if !enableHTTP2 </span><span class="cov0" title="0">{
                tlsOpts = append(tlsOpts, disableHTTP2)
        }</span>

        // Create watchers for metrics and webhooks certificates
        <span class="cov0" title="0">var metricsCertWatcher, webhookCertWatcher *certwatcher.CertWatcher

        // Initial webhook TLS options
        webhookTLSOpts := tlsOpts

        if webhookCertPath != "" </span><span class="cov0" title="0">{
                setupLog.Info("Initializing webhook certificate watcher using provided certificates",
                        "webhook-cert-path", webhookCertPath, "webhook-cert-name", webhookCertName, "webhook-cert-key", webhookCertKey)

                var err error
                webhookCertWatcher, err = certwatcher.New(
                        filepath.Join(webhookCertPath, webhookCertName),
                        filepath.Join(webhookCertPath, webhookCertKey),
                )
                if err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "Failed to initialize webhook certificate watcher")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">webhookTLSOpts = append(webhookTLSOpts, func(config *tls.Config) </span><span class="cov0" title="0">{
                        config.GetCertificate = webhookCertWatcher.GetCertificate
                }</span>)
        }

        <span class="cov0" title="0">webhookServer := webhook.NewServer(webhook.Options{
                TLSOpts: webhookTLSOpts,
        })

        // Metrics endpoint is enabled in 'config/default/kustomization.yaml'. The Metrics options configure the server.
        // More info:
        // - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.20.0/pkg/metrics/server
        // - https://book.kubebuilder.io/reference/metrics.html
        metricsServerOptions := metricsserver.Options{
                BindAddress:   metricsAddr,
                SecureServing: secureMetrics,
                TLSOpts:       tlsOpts,
        }

        if secureMetrics </span><span class="cov0" title="0">{
                // FilterProvider is used to protect the metrics endpoint with authn/authz.
                // These configurations ensure that only authorized users and service accounts
                // can access the metrics endpoint. The RBAC are configured in 'config/rbac/kustomization.yaml'. More info:
                // https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.20.0/pkg/metrics/filters#WithAuthenticationAndAuthorization
                metricsServerOptions.FilterProvider = filters.WithAuthenticationAndAuthorization
        }</span>

        // If the certificate is not specified, controller-runtime will automatically
        // generate self-signed certificates for the metrics server. While convenient for development and testing,
        // this setup is not recommended for production.
        //
        // TODO(user): If you enable certManager, uncomment the following lines:
        // - [METRICS-WITH-CERTS] at config/default/kustomization.yaml to generate and use certificates
        // managed by cert-manager for the metrics server.
        // - [PROMETHEUS-WITH-CERTS] at config/prometheus/kustomization.yaml for TLS certification.
        <span class="cov0" title="0">if metricsCertPath != "" </span><span class="cov0" title="0">{
                setupLog.Info("Initializing metrics certificate watcher using provided certificates",
                        "metrics-cert-path", metricsCertPath, "metrics-cert-name", metricsCertName, "metrics-cert-key", metricsCertKey)

                var err error
                metricsCertWatcher, err = certwatcher.New(
                        filepath.Join(metricsCertPath, metricsCertName),
                        filepath.Join(metricsCertPath, metricsCertKey),
                )
                if err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "to initialize metrics certificate watcher", "error", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">metricsServerOptions.TLSOpts = append(metricsServerOptions.TLSOpts, func(config *tls.Config) </span><span class="cov0" title="0">{
                        config.GetCertificate = metricsCertWatcher.GetCertificate
                }</span>)
        }

        <span class="cov0" title="0">mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
                Scheme:                 scheme,
                Metrics:                metricsServerOptions,
                WebhookServer:          webhookServer,
                HealthProbeBindAddress: probeAddr,
                LeaderElection:         enableLeaderElection,
                LeaderElectionID:       "95d1dc58.kvm.cloud.sap",
                // LeaderElectionReleaseOnCancel defines if the leader should step down voluntarily
                // when the Manager ends. This requires the binary to immediately end when the
                // Manager is stopped, otherwise, this setting is unsafe. Setting this significantly
                // speeds up voluntary leader transitions as the new leader don't have to wait
                // LeaseDuration time first.
                //
                // In the default scaffold provided, the program ends immediately after
                // the manager stops, so would be fine to enable this option. However,
                // if you are doing or is intended to do any operation such as perform cleanups
                // after the manager stops then its usage might be unsafe.
                // LeaderElectionReleaseOnCancel: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to start manager")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if os.Getenv("ENABLE_WEBHOOKS") != "false" </span><span class="cov0" title="0">{
                if err = webhookkvmcloudsapv1.SetupLabelsInjectorWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "unable to create webhook", "webhook", "Netbox")
                        os.Exit(1)
                }</span>
        }
        // +kubebuilder:scaffold:builder

        <span class="cov0" title="0">if metricsCertWatcher != nil </span><span class="cov0" title="0">{
                setupLog.Info("Adding metrics certificate watcher to manager")
                if err := mgr.Add(metricsCertWatcher); err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "unable to add metrics certificate watcher to manager")
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if webhookCertWatcher != nil </span><span class="cov0" title="0">{
                setupLog.Info("Adding webhook certificate watcher to manager")
                if err := mgr.Add(webhookCertWatcher); err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "unable to add webhook certificate watcher to manager")
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up health check")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if err := mgr.AddReadyzCheck("readyz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up ready check")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err := (&amp;controller.PodReconciler{
                Client: mgr.GetClient(),
                Scheme: mgr.GetScheme(),
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller", "controller", "Pod")
        }</span>

        <span class="cov0" title="0">setupLog.Info("starting manager")
        if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "problem running manager")
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
SPDX-FileCopyrightText: Copyright 2024 SAP SE or an SAP affiliate company and cobaltcore-dev contributors
SPDX-License-Identifier: Apache-2.0

Licensed under the Apache License, LibVirtVersion 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
        "context"

        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logger "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/manager"

        "github.com/cobaltcore-dev/labels-injector/internal"
)

type PodReconciler struct {
        client.Client
        Scheme *runtime.Scheme
}

func (r *PodReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        log := logger.FromContext(ctx, "controller", "pod").WithName("Reconcile")

        pod := &amp;v1.Pod{}
        if err := r.Get(ctx, req.NamespacedName, pod); client.IgnoreNotFound(err) != nil </span><span class="cov0" title="0">{
                // ignore not found errors, could be deleted
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">log.Info("Reconciling Pod", "pod", req.NamespacedName)

        // Fetch Node object of the pod
        node := &amp;v1.Node{}
        if err := r.Get(ctx, client.ObjectKey{Name: pod.Spec.NodeName}, node); client.IgnoreNotFound(err) != nil </span><span class="cov0" title="0">{
                // ignore not found errors, could be deleted
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, internal.TransferLabel(ctx, pod, node, r.Client)</span>
}

func (r *PodReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        log := logger.FromContext(context.Background(), "controller", "pod")
        log.Info("Setting up Pod controller with manager")

        err := mgr.Add(manager.RunnableFunc(func(context.Context) error </span><span class="cov0" title="0">{
                return r.ReconcileAllPods()
        }</span>))
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "unable add a runnable to the manager")
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (r *PodReconciler) ReconcileAllPods() error <span class="cov0" title="0">{
        log := logger.FromContext(context.Background(), "controller", "pod").WithName("ReconcileAllPods")

        log.Info("Reconciling all Pods")

        // List all Pods in the cluster
        podList := &amp;v1.PodList{}
        if err := r.List(context.Background(), podList); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, pod := range podList.Items </span><span class="cov0" title="0">{
                if _, err := r.Reconcile(context.Background(), ctrl.Request{NamespacedName: client.ObjectKeyFromObject(&amp;pod)}); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "Failed to reconcile Pod", "pod", pod.Name)
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
SPDX-FileCopyrightText: Copyright 2025 SAP SE or an SAP affiliate company and cobaltcore-dev contributors
SPDX-License-Identifier: Apache-2.0

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package internal

import (
        "context"
        "fmt"

        v1 "k8s.io/api/core/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

func TransferLabel(ctx context.Context, pod *v1.Pod, node *v1.Node, d client.Client) error <span class="cov0" title="0">{
        var transferLabels = []string{
                "kubernetes.metal.cloud.sap/name",
                "kubernetes.metal.cloud.sap/cluster",
                "kubernetes.metal.cloud.sap/bb",
                "topology.kubernetes.io/region",
                "topology.kubernetes.io/zone",
        }

        if pod.Labels == nil </span><span class="cov0" title="0">{
                pod.Labels = make(map[string]string)
        }</span>

        <span class="cov0" title="0">patch := client.MergeFrom(pod.DeepCopy())
        // transfer the labels from the node to the pod
        for _, label := range transferLabels </span><span class="cov0" title="0">{
                if nodeLabel, ok := node.Labels[label]; ok </span><span class="cov0" title="0">{
                        pod.Labels[label] = nodeLabel
                }</span>
        }
        <span class="cov0" title="0">if _, ok := node.Labels["kubernetes.metal.cloud.sap/name"]; !ok </span><span class="cov0" title="0">{
                // legacy cluster fallback strategy
                pod.Labels["kubernetes.metal.cloud.sap/name"] = node.Name
        }</span>

        // patch the pod object
        <span class="cov0" title="0">if err := d.Patch(ctx, pod, patch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("patch Pod %s/%s: %w", pod.Namespace, pod.Name, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
SPDX-FileCopyrightText: Copyright 2025 SAP SE or an SAP affiliate company and cobaltcore-dev contributors
SPDX-License-Identifier: Apache-2.0

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "net/http"

        v1 "k8s.io/api/core/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logger "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        "github.com/cobaltcore-dev/labels-injector/internal"
)

// SetupLabelsInjectorWithManager registers the webhook for Pod/bindings in the manager.
func SetupLabelsInjectorWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        h := &amp;PodLabelTransferHandler{
                admission.NewDecoder(mgr.GetScheme()),
                mgr.GetClient(),
        }
        mgr.GetWebhookServer().Register("/admission--v1-pods-binding", &amp;webhook.Admission{Handler: h})
        return nil
}</span>

// +kubebuilder:rbac:groups=core,resources=nodes,verbs=get;list;watch
// +kubebuilder:rbac:groups=core,resources=pods,verbs=get;list;watch;patch
// +kubebuilder:webhook:path=/admission--v1-pods-binding,mutating=false,failurePolicy=ignore,sideEffects=None,groups="",resources=pods/binding,verbs=create;update,versions=v1,name=labels-injector.kvm.cloud.sap,admissionReviewVersions=v1

// PodLabelTransferHandler struct is responsible for transferring labels from the node to the pod.
//
// NOTE: The +kubebuilder:object:generate=false marker prevents controller-gen from generating DeepCopy methods,
// as it is used only for temporary operations and does not need to be deeply copied.
type PodLabelTransferHandler struct {
        admission.Decoder
        client.Client
}

func (d *PodLabelTransferHandler) Handle(ctx context.Context, request admission.Request) admission.Response <span class="cov0" title="0">{
        log := logger.FromContext(ctx).WithName("label-injector")

        log.Info("Handling request", "reqest", request.Name)

        // check if the request is for a binding
        if request.Kind.Kind != "Binding" </span><span class="cov0" title="0">{
                log.Error(nil, "expected a binding request", "kind", request.Kind.Kind)
                return admission.Allowed("Not a binding request")
        }</span>

        <span class="cov0" title="0">binding := &amp;v1.Binding{}
        if err := d.Decode(request, binding); err != nil </span><span class="cov0" title="0">{
                return admission.Errored(http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">if binding.Target.Kind != "Node" </span><span class="cov0" title="0">{
                // ignore binding for non-node targets
                log.Info("ignoring, target is not a node", "kind", binding.Target.Kind)
                return admission.Allowed("Binding is not for a node")
        }</span>

        <span class="cov0" title="0">nodeName := binding.Target.Name
        if nodeName == "" </span><span class="cov0" title="0">{
                log.Info("ignoring, node name is empty", "pod", binding.Name)
                return admission.Allowed("Node name is empty")
        }</span>

        // fetch node object
        <span class="cov0" title="0">node := &amp;v1.Node{}
        if err := d.Get(ctx, client.ObjectKey{Name: nodeName}, node); client.IgnoreNotFound(err) != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to fetch node", "name", nodeName)
                return admission.Allowed("").WithWarnings("Failed to fetch node")
        }</span>

        // fetch the pod object
        <span class="cov0" title="0">pod := &amp;v1.Pod{}
        if err := d.Get(ctx, client.ObjectKeyFromObject(binding), pod); client.IgnoreNotFound(err) != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to fetch pod", "object", client.ObjectKeyFromObject(binding))
                return admission.Allowed("").WithWarnings("Failed to fetch pod")
        }</span>

        <span class="cov0" title="0">if err := internal.TransferLabel(ctx, pod, node, d.Client); client.IgnoreNotFound(err) != nil </span><span class="cov0" title="0">{
                log.Error(err, "Failed to patch pod", "object", client.ObjectKeyFromObject(pod))
        }</span>

        <span class="cov0" title="0">return admission.Allowed("")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
